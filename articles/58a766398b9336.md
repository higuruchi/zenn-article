---
title: "クリーンアーキテクチャと依存関係逆転の法則"
emoji: "🐕"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: []
published: false
---

## アプリケーションの仕様

今回作成したアプリケーションはユーザ名とパスワードを含んだリクエストを受けると、ユーザ名とパスワードのペアが正しいか検証し、正しい場合はトークンを返すアプリケーションです。ソースコードは以下のリンクにあります。

https://github.com/higuruchi/certification-app

以下は実行時のデモです。

```bash
$ curl -w '\n' 'http://<IP Address>:<Port>/' --data 'name=higuruchi&password=pass' -XPOST
{"token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiZXhwIjoxNjMxNjgxODk3fQ.YEWrN5T2rQyferN2kt2V3up3fW5N030jlDphkzXx7JU"}
$  curl -w '\n' 'http://<IP Address>:<Port>/' --data 'name=higuruchi&password=faultpass' -XPOST
{"message":"unauthorized"}
```

### 処理の流れ

![](https://storage.googleapis.com/zenn-user-upload/c62c2a28df8a-20211206.png)

## 使用技術

- Go 1.17
    - Echo(https://echo.labstack.com/)
    - Wire(https://github.com/google/wire)
- MySQL Ver 8.0.26

## クリーンアーキテクチャって？

クリーンアーキテクチャとはそれぞれの層を分離し、依存の流れを外から中だけの一方向にすることでDBやフレームワークからの独立性を確保することを目的としたアーキテクチャです。以下の図が有名ですが、正確に４層である必要はなく、「依存性のルール」、「関心の分離」、「依存関係逆転の法則」が重要とされています。

![](https://storage.googleapis.com/zenn-user-upload/1de1a18e5e52-20211206.jpeg)

## それぞれの層の解説

### 　アプリケーションのディレクトリ構造

./internal以下のディレクトリがそれぞれの層に対応しています。

```bash
❯ tree
.
├── README.md
├── cmd
│   └── main.go
├── go.mod
├── go.sum
└── internal
    ├── config
    │   └── cmd
    │       └── root.go
    ├── di
    │   ├── wire.go
    │   └── wire_gen.go
    ├── externalinterface
    │   ├── database
    │   │   ├── database.go
    │   │   └── table.sql
    │   └── server
    │       └── server.go
    ├── interfaceadapter
    │   ├── controller
    │   │   └── user_controller.go
    │   └── repository
    │       ├── model
    │       │   └── user_model.go
    │       ├── user_repository.go
    │       ├── util.go
    │       └── worker
    │           └── database_handler.go
    └── usecase
        ├── model
        │   └── user_model.go
        ├── repository
        │   └── user_repository.go
        └── user_usecase.go

16 directories, 18 files
```


### Enterprise Business Rules

アプリケーションのビジネスロジックを表現するEntityが所属するレイヤーです。
今回のアプリケーションでは利用していませんが、通常はアプリケーションにとって重要なデータの構造体などが定義されます。

### Application Business Rules

Entityが持つ振る舞いを表現するためのレイヤーで、Entityに所属するオブジェクトと協調しユースケースを達成します。

今回のアプリケーションの場合、```./internal/usecase```以下のディレクトリに当たります。

ユーザ名とパスワードから、ログインができるかどうかを検証するLoginユースケースを定義しています。

```FindUser```メソッドは```./internal/usecase/repository/user_repository.go```の```UserRepository```インタフェースに定義されています。

### Interface Adapter (interfaceadapter)

Frameworks & Driversの層から来たデータを内側の層で扱えるデータの変換にする役割を果たします。

### Frameworks & Drivers (externalinterface)

データベースのドライバーやWebフレームワークなどの外部との連携の役割を果たすコードが所属します。
このレイヤーでは利用するミドルウェアやフレームワークによって大きく実装が異なります。そのため、他の層のコードと比較して頻繁に変更される可能性があります。
また、フロントエンドのユーザインタフェースとなるコードもこの層に所属します。

### 依存関係逆転の法則

クリーンアーキテクチャは下図のように外の層から内の層への依存に限定しているのですが、

![](https://storage.googleapis.com/zenn-user-upload/98b0989632f0-20211228.png)

Interface Adater層からExternal Interface層のDBにアクセスしたい場合などのように、内側から外側への依存関係を発生させたい場合があります。
その際に直接モジュールなどにアクセスをした場合、外から内側のみの依存という制約を破り、適切でない依存関係が発生します。
これを解消するために依存関係逆転の法則を用います。

![](https://storage.googleapis.com/zenn-user-upload/f7ee48902648-20211228.png)

これによって、プログラムないの依存関係を一方向に保つことができ、externalinterface層のコンポーネントをプラグインとして扱うことができるため、DBを変更やフレームワークの変更にも柔軟に対応することができます。

依存関係逆転の法則を説明するために、モジュール間の依存関係が下図のような場合を考えます。
mainモジュール内でMA1モジュールを呼び出し、MA1モジュール内でMB1を呼び出しています。

![](https://storage.googleapis.com/zenn-user-upload/81536c4191d2-20211228.jpg)

このような依存関係の場合、MB1のプログラムを変更した際にMA1のプログラムも変更をしなければならない可能性が発生します。

しかし、ここでポリモーフィズムを利用し、MB1を呼び出すことによって、依存関係を逆転させることができます。

![](https://storage.googleapis.com/zenn-user-upload/df47bdf7f0b1-20211228.jpg)

MB1をインタフェースに依存させ、MA1はインタフェースを介してMB1のモジュールを呼び出すことで、MB1をプラグインとして扱うことができます。そのため、MB1内のプログラムを変更したとしてもMA1に影響を与えることはなく、依存関係によって生じるバグやプログラム破壊を防いでくれます。

![](https://storage.googleapis.com/zenn-user-upload/ddd131e19b91-20211228.jpg)

今回作成したアプリケーションで、依存関係逆転の法則を利用しているプログラムの一例をあげます。
usecase層からinterfaceadapter層のモジュールを呼び出す際の処理です。

![](https://storage.googleapis.com/zenn-user-upload/921ab067b208-20211228.jpg)

```Go:./internal/usecase/repository/user_repository.go
// usecase層から呼び出すためにinterfaceadapter層のコンポーネントが満たすべきインタフェースを定義している
package repository

import (
	"github.com/higuruchi/certification-app/internal/usecase/model"
)

type UserRepository interface {
	FindUser(model.User) (bool, error)
}
```

```Go:./internal/user_usecase.go
package usecase

import (
	"fmt"
	"github.com/higuruchi/certification-app/internal/usecase/repository"
	"github.com/higuruchi/certification-app/internal/usecase/model"
)

type userUsecase struct {
    // interfaceadapter層のモジュールを呼び出すためのインタフェースが構造体のメンバとして定義されている
	userRepository repository.UserRepository
}

type UserUsecase interface {
	Login(model.User) (bool, error)
}

// userUsecaseのコンストラクタ
func NewUserUsecase(userRepository repository.UserRepository) UserUsecase {
	return &userUsecase {
		userRepository: userRepository,
	}
}

func (userUsecase *userUsecase) Login(user model.User) (bool, error) {
    // ここでinterfaceadapter層のモジュールをインタフェースを介して呼び出している
	isLogin, err := userUsecase.userRepository.FindUser(user)
	if err != nil {
		return false, fmt.Errorf("calling useUsecase.userRepository.FindUser:%w", err)
	}

	return isLogin, nil
}
```

```Go

package repository

import (
	"fmt"
	"github.com/higuruchi/certification-app/internal/interfaceadapter/repository/worker"
	"github.com/higuruchi/certification-app/internal/usecase/model"

)

type UserRepository struct {
    // externalinterface層のモジュールを呼び出すためのインタフェースがメンバとして定義されている
	databaseHandler worker.DatabaseHandler
}

// UserRepositoryのコンストラクタ
func NewUserRepository(
	databaseHandler worker.DatabaseHandler,
) *UserRepository {
	return &UserRepository{
		databaseHandler: databaseHandler,
	}
}

// SQL分を構築しSQLを実行するためexternalinterface層のモジュールを呼び出すモジュール
func (userRepository *UserRepository) FindUser(user model.User) (bool, error) {
	sql := `
    SELECT CASE
		WHEN COUNT(*)=1 THEN 1
		ELSE 0
		END
    FROM users
    WHERE name=? AND password=?
`
	rows, err := userRepository.databaseHandler.Query(sql, user.Name, hashPassword(user.Password))
	defer rows.Close()
	if err != nil {
		return false, fmt.Errorf("calling userRepository.databaseHandler.Query: %w", err)
	}

	var isLogin int
	rows.Next()
	if err := rows.Scan(&isLogin); err != nil {
		return false, fmt.Errorf("calling rows.Scan: %w", err)
	}

	if isLogin == 0 {
		return false, nil
	}

	return true, nil
}
```